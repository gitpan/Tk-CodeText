
=head1 NAME

Tk::CodeText - a TextUndo widget with syntax highlighting capabilities

=head1 SYNOPSIS

=over 4

 use Tk;
 require Tk::CodeText;

 my $m = new MainWindow;

 my $e = $m->Scrolled('CodeText',
 	-disablemenu => 1,
 	-syntax => 'Perl',
 	-scrollbars => 'se',
 )->pack(-expand => 1, -fill => 'both');

 $m->configure(-menu => $e->menu);
 $m->MainLoop;

=back

=head1 DESCRIPTION

=over 4

Tk::CodeText inherits Tk::TextUndo and all its options and methods. Besides
syntax highlighting, methods are provided for commenting and uncommenting
as well as indenting and unindenting a selected area, matching pairs of braces, brackets and
brackets and curlies and automatic indenting of new lines.

Syntax highlighting is done through a plugin approach. Currently there is
support for B<Perl>, B<Pod>,  B<HTML> and B<Xresources>. Adding languages 
is a matter of writing plugin modules. Theoretically this is not limited to programming languages. 
The plugin approach could also provide the possibility for grammar or spell checking in spoken 
languages.

=back

=head1 OPTIONS

=over 4

=item Name: B<autoindent>

=item Class: B<Autoindent>

=item Switch: B<-autoindent>

Boolean, when you press the enter button, should the next line begin at the
same position as the current line or not. By default B<false>.

=item Name: B<commentchar>

=item Class: B<Commentchar>

=item Switch: B<-commentchar>

By default "#".

=item Name: B<disablemenu> 

=item Class: B<Disablemenu>

=item Switch: B<-disablemenu>

Boolean, by default 0. In case you don't want the menu under the
right mouse button to pop up.

=item Name: B<indentchar>

=item Class: B<Indentchar>

=item Switch: B<-indentchar>

By default "\t".

=item Name: B<match>

=item Class: B<Match>

=item Switch: B<-match>

string of pairs for brace/bracket/curlie etc matching. If this description
doesn't make anything clear, don't worry, the default setting will:

 '[]{}()'

if you don't want matching to be available, simply set it to ''.

=item Name: B<matchoptions>

=item Class: B<Matchoptions>

=item Switch: B<-matchoptions>

Options list for the tag 'Match'. By default:

 [-background => 'red', -foreground => 'yellow']

You can also specify this option as a space separated string. Might come in
handy for your Xresource files.

 "-background red -foreground yellow"

=item Name: not available

=item Class: not available

=item Switch B<-rules>

Specify the color and font options for highlighting. You specify a list
looking a bit like this.

 [
     ['Tagname1', @options1],
     ['Tagname2', @options2],
 ]

The names of the tags are depending on the syntax that is highlighted. 
See the language modules for more information about this data structure.

=item Name: rulesdir

=item Class: Rulesdir

=item Switch B<-rulesdir>

Specify the directory where this widget stores its coloring defenitions.
Files in this directory are stored as "HTML.rules", "Perl.rules" etc.
By default it is set to '', which means that when you switch syntax
the highlighting rules are not loaded or stored. The hard coded defaults
in the language modules will be used.

=item Name: B<syntax>

=item Class: B<Syntax>

=item Switch: B<-syntax>


Specifies the language for highlighting. At this moment the possible
values are B<None>, B<HTML>, B<Perl>, B<Pod> and B<Xresources>. 
By default B<None>

Alternatively it is possible to specify a reference to your independent plugin.

=item Name: Not available

=item Class: Not available

=item Switch: B<-updatecall>

Here you can specify a callback that will be executed whenever the insert
cursor has moved or text has been modified, so your application can keep
track of position etc. Don't make this callback to heavy, the widget will
get sluggish quickly.

=back

There are some undocumented options. They are used internally. 
It is propably best to leave them alone.

=cut

=head1 METHODS

=over 4

=item B<doAutoIndent>

=item B<highlight>

=item B<highlightCheck>

=item B<highlightLine>

=item B<highlightPlug>

=item B<highlightPlugInit>

=item B<highlightPurge>

=item B<highlightVisual>

=item B<linenumber>

=item B<matchCheck>

=item B<matchFind>

=item B<rulesEdit>

Pops up a window that enables the user the set the color and font options
for the current syntax.

=item B<rulesFetch>

=item B<rulesSave>

=item B<selectionComment>

=item B<selectionIndent>

=item B<selectionModify>

=item B<selectionUnComment>

=item B<selectionUnIndent>

=back

=head1 SYNTAX HIGHLIGHTING

This section is a brief description of how the syntax highlighting process
works.

B<Initiating plugin>

The highlighting plugin is only then initiated when it is needed. When some
highlighting needs to be done, the widget calls B<highlightPlug> to retrieve
a reference to the plugin. 

B<highlightPlug> checks wether a plugin is present. Next it will check whether  the B<-rules> option has been 
specified or whter the B<-rules> option has changed. If no rules are specified in B<-rules>, it will look for a pathname
in the B<-rulesdir> option. If that is found it will try to load a file called '*.rules', where * is the value of B<-syntax>. 

If no plugin is present, or the B<-syntax> option has changed value,
B<highlightPlug> loads the plugin. and constructs optionally giving it 
a reference to the found rules as parameter. if no rules
are specified, the plugin will use its internal hardcoded defaults.

B<Changing the rules>

A set of rules is a list, containing lists of tagnames, followed by options. 
If you want to see what they look like, you can have a look at the constructors
of each plugin module. Every plugin has a fixed set of tagnames it can handle.

There are two ways to change the rules.

You can invoke the B<rulesEdit> method, which is also available through the 
B<View> menu. The result is a popup in which you can specify color and font
options for each tagname. After pressing 'Ok', the edited rules will be applied.
If B<-rulesdir> is specified, the rules will be saved on disk as
I<rulesdir/syntax.rules>.

You can also use B<configure> to specify a new set of rules. In this you have
ofcause more freedom to use all available tag options. For more details about
those there is a nice section about tag options in the Tk::Text documentation.
After the call to B<configure> it is wise to call B<highlightPlug>.

B<Highlighting text>

Syntax highlighting is done in a lazy manor. Only that piece of text is
highlighted that is needed to present the user a pretty picture. This is
done to minimize use of system resources. Highlighting is running on the
foreground. Jumping directly to the end of a long fresh loaded textfile may
very well take a couple of seconds.

Highlighting is done on a line to line basis. At the end of each line the
highlighting status is saved in the list in B<-colorinf>, so when highlighting
the next line, the B<highlight> method of B<CodeText> will know how to begin.

The line that needs highlighting is offered to the B<highlight> method of
the plugin. This method returns a list of offset and tagname pairs.
Take for example the following line of perl code.

 my $mother = 'older than i am';

The B<highlight> method of the Perl plugin will return the following list;

 (2 => 'Reserved',    #'my' is a reserved word
  1 => 'DEFAULT',     #Space
  7 => 'Variable',    #$mother
  1 => 'DEFAULT',     #Space
  1 => 'Operator',    #'='
  1 => 'DEFAULT',     #Space
  17 => 'String',     #'older than i am'
  1 => 'DEFAULT',)    #;

The B<highlight> method of CodeText will then mark positions 0 to 2 as 
'Reserved', positions 2 to 3 as 'DEFAULT', positions 3 to 10 as 'Variable',
etcetera.

=cut

=head1 WRITING PLUGINS

After writing a couple of plugins myself i have come to a couple of guidelines
about how to set them up. If you are interested in adding support for your
own syntax highlighting problem or language this section is of interest to you.

B<From scratch>

If you choose to build a plugin completely from scratch, your module needs
to meet the following requirements.

 - If you want to write a formal addition to Tk::CodeText, 
   your plugin must be in the namespace 
   Tk::CodeText::YourSyntax.
 - The constructor is called 'new', and it should accept 
   a reference a reference to a list of rules as parameters.
 - The following methods will be called upon by Tk::CodeText: 
     highlight, stateCompare, rules, setSate, 
     getState, syntax.

More information about those methods is available in the documentation of
Tk::CodeText::None and Tk::CodeText::Template. Good luck, you're on your own now.

B<Inheriting Tk::CodeText::Template>

For many not too complicated highlighting problems Tk::CodeText::Template
provides a nice basis to start from. I have been able to write to
easily write support for HTML, Pod  and Xresources files. Anyway, your code
should look like this:

 package Tk::CodeText::MySyntax;
 
 use strict;
 use base('Tk::CodeText::Template');
 
 sub new {
    my ($proto, $wdg, $rules) = @_;
    my $class = ref($proto) || $proto;

Next, specify the set of hardcoded rules.

    if (not defined($rules)) {
       $rules =  [
          ['Tagname1', -foreground => 'red'],
          ['Tagname1', -foreground => 'red'],
       ];
    };

Call the constructor of Tk::CodeText::Template and bless your
object.

    my $self = $class->SUPER::new($wdg, $rules);
    bless ($self, $class);

Perhaps do a couple of other things

    #$self->listAdd('listname', value1, value2 ....)

    return $self;
 }

Then you need a B<highlight> method. This method will be given a line of text
as parameter by CodeText.

 sub highlight {
    my ($self $txt) = @_;

Reset everything so that there is a clean beginning;

    $cw->snippet('');
    my $out = $self->out;
    @$out = ();

Here comes the difficult part, where you are on your own. Perhaps you can
draw some inspiration from existing highlighting plugins. The trick is to
repeatedly build a text snippet using the B<snippet> and/or B<snippetAppend>
methods of Tk::CodeText::Template. Whenever you have a snippet, you want to
assign a tag to, you call B<snippetParse>. The methods B<stack>, B<stackPush>,
and B<stackPush> are used to keep track of the current, possibly nested,
tag. B<snippetParse> pushes the length of the snippet and the tagname that
is on top of the stack to the @$out array. For more information read the
documentation of Tk::CodeText::Template.

After you're done highlighting, you still have to return your result;

    return @$out;
 }

And then, last but not least, you need a B<syntax> method.

 sub syntax {
    my $self = shift;
    return 'MySyntax'
 }
 1;

B<Using another module as basis>

An example of this approach is the Perl syntax module.

Also with this approach you will have to meet the minimum criteria
as set out in the B<From scratch> section.

=cut

=head1 AUTHOR

=over 4

=item Hans Jeuken (haje@toneel.demon.nl)

=back

=cut

=head1 BUGS

=over 4

Unknown.

=back

=cut

=head1 TODO

=over 4

=item Find and eliminate bugs.

=item Improve documentation.

=item Add additional language modules. I am going to need help on this one.

=item Optimize highlighting methods.

Syntax highlighting consumes a lot of system resources. Squeezing every bit
of performance out of it might make it less sluggish on slow systems, like
a pentium at 100Mhz.

If you're interested in this module, please have a look at the code 
and point out to me where I might have overlooked something. Of special
interest are the CodeText methods B<highlight> and B<highlightLine> as well as
the code of the language modules.

=item Add variable options for linenumber, position, filename etc.

=item Make the rules editor fail safe.

=back

=cut

=head1 SEE ALSO

=over 4

=item B<Tk::Text>, B<Tk::TextUndo>, B<Tk::CodeText::None>, B<Tk::CodeText::Perl>
B<Tk::CodeText::HTML>

=back

=cut



